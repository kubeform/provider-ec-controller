/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApm{}).Type1()):                              DeploymentSpecApmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApmConfig{}).Type1()):                        DeploymentSpecApmConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearch{}).Type1()):                    DeploymentSpecElasticsearchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchConfig{}).Type1()):              DeploymentSpecElasticsearchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchSnapshotSource{}).Type1()):      DeploymentSpecElasticsearchSnapshotSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchTopologyAutoscaling{}).Type1()): DeploymentSpecElasticsearchTopologyAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearch{}).Type1()):                 DeploymentSpecEnterpriseSearchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearchConfig{}).Type1()):           DeploymentSpecEnterpriseSearchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServer{}).Type1()):               DeploymentSpecIntegrationsServerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServerConfig{}).Type1()):         DeploymentSpecIntegrationsServerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibana{}).Type1()):                           DeploymentSpecKibanaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibanaConfig{}).Type1()):                     DeploymentSpecKibanaConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecObservability{}).Type1()):                    DeploymentSpecObservabilityCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApm{}).Type1()):                              DeploymentSpecApmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApmConfig{}).Type1()):                        DeploymentSpecApmConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearch{}).Type1()):                    DeploymentSpecElasticsearchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchConfig{}).Type1()):              DeploymentSpecElasticsearchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchSnapshotSource{}).Type1()):      DeploymentSpecElasticsearchSnapshotSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchTopologyAutoscaling{}).Type1()): DeploymentSpecElasticsearchTopologyAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearch{}).Type1()):                 DeploymentSpecEnterpriseSearchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearchConfig{}).Type1()):           DeploymentSpecEnterpriseSearchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServer{}).Type1()):               DeploymentSpecIntegrationsServerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServerConfig{}).Type1()):         DeploymentSpecIntegrationsServerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibana{}).Type1()):                           DeploymentSpecKibanaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibanaConfig{}).Type1()):                     DeploymentSpecKibanaConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecObservability{}).Type1()):                    DeploymentSpecObservabilityCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DeploymentSpecApmCodec struct {
}

func (DeploymentSpecApmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecApm)(ptr) == nil
}

func (DeploymentSpecApmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecApm)(ptr)
	var objs []DeploymentSpecApm
	if obj != nil {
		objs = []DeploymentSpecApm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecApmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecApm)(ptr) = DeploymentSpecApm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecApm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecApm)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecApm)(ptr) = DeploymentSpecApm{}
			}
		} else {
			*(*DeploymentSpecApm)(ptr) = DeploymentSpecApm{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecApm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecApm)(ptr) = obj
		} else {
			*(*DeploymentSpecApm)(ptr) = DeploymentSpecApm{}
		}
	default:
		iter.ReportError("decode DeploymentSpecApm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecApmConfigCodec struct {
}

func (DeploymentSpecApmConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecApmConfig)(ptr) == nil
}

func (DeploymentSpecApmConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecApmConfig)(ptr)
	var objs []DeploymentSpecApmConfig
	if obj != nil {
		objs = []DeploymentSpecApmConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApmConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecApmConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecApmConfig)(ptr) = DeploymentSpecApmConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecApmConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApmConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecApmConfig)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecApmConfig)(ptr) = DeploymentSpecApmConfig{}
			}
		} else {
			*(*DeploymentSpecApmConfig)(ptr) = DeploymentSpecApmConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecApmConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecApmConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecApmConfig)(ptr) = obj
		} else {
			*(*DeploymentSpecApmConfig)(ptr) = DeploymentSpecApmConfig{}
		}
	default:
		iter.ReportError("decode DeploymentSpecApmConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecElasticsearchCodec struct {
}

func (DeploymentSpecElasticsearchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecElasticsearch)(ptr) == nil
}

func (DeploymentSpecElasticsearchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecElasticsearch)(ptr)
	var objs []DeploymentSpecElasticsearch
	if obj != nil {
		objs = []DeploymentSpecElasticsearch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecElasticsearchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecElasticsearch)(ptr) = DeploymentSpecElasticsearch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecElasticsearch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecElasticsearch)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecElasticsearch)(ptr) = DeploymentSpecElasticsearch{}
			}
		} else {
			*(*DeploymentSpecElasticsearch)(ptr) = DeploymentSpecElasticsearch{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecElasticsearch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecElasticsearch)(ptr) = obj
		} else {
			*(*DeploymentSpecElasticsearch)(ptr) = DeploymentSpecElasticsearch{}
		}
	default:
		iter.ReportError("decode DeploymentSpecElasticsearch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecElasticsearchConfigCodec struct {
}

func (DeploymentSpecElasticsearchConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecElasticsearchConfig)(ptr) == nil
}

func (DeploymentSpecElasticsearchConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecElasticsearchConfig)(ptr)
	var objs []DeploymentSpecElasticsearchConfig
	if obj != nil {
		objs = []DeploymentSpecElasticsearchConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecElasticsearchConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecElasticsearchConfig)(ptr) = DeploymentSpecElasticsearchConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecElasticsearchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecElasticsearchConfig)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecElasticsearchConfig)(ptr) = DeploymentSpecElasticsearchConfig{}
			}
		} else {
			*(*DeploymentSpecElasticsearchConfig)(ptr) = DeploymentSpecElasticsearchConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecElasticsearchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecElasticsearchConfig)(ptr) = obj
		} else {
			*(*DeploymentSpecElasticsearchConfig)(ptr) = DeploymentSpecElasticsearchConfig{}
		}
	default:
		iter.ReportError("decode DeploymentSpecElasticsearchConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecElasticsearchSnapshotSourceCodec struct {
}

func (DeploymentSpecElasticsearchSnapshotSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecElasticsearchSnapshotSource)(ptr) == nil
}

func (DeploymentSpecElasticsearchSnapshotSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecElasticsearchSnapshotSource)(ptr)
	var objs []DeploymentSpecElasticsearchSnapshotSource
	if obj != nil {
		objs = []DeploymentSpecElasticsearchSnapshotSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchSnapshotSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecElasticsearchSnapshotSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecElasticsearchSnapshotSource)(ptr) = DeploymentSpecElasticsearchSnapshotSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecElasticsearchSnapshotSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchSnapshotSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecElasticsearchSnapshotSource)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecElasticsearchSnapshotSource)(ptr) = DeploymentSpecElasticsearchSnapshotSource{}
			}
		} else {
			*(*DeploymentSpecElasticsearchSnapshotSource)(ptr) = DeploymentSpecElasticsearchSnapshotSource{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecElasticsearchSnapshotSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchSnapshotSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecElasticsearchSnapshotSource)(ptr) = obj
		} else {
			*(*DeploymentSpecElasticsearchSnapshotSource)(ptr) = DeploymentSpecElasticsearchSnapshotSource{}
		}
	default:
		iter.ReportError("decode DeploymentSpecElasticsearchSnapshotSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecElasticsearchTopologyAutoscalingCodec struct {
}

func (DeploymentSpecElasticsearchTopologyAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr) == nil
}

func (DeploymentSpecElasticsearchTopologyAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr)
	var objs []DeploymentSpecElasticsearchTopologyAutoscaling
	if obj != nil {
		objs = []DeploymentSpecElasticsearchTopologyAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchTopologyAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecElasticsearchTopologyAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr) = DeploymentSpecElasticsearchTopologyAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecElasticsearchTopologyAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchTopologyAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr) = DeploymentSpecElasticsearchTopologyAutoscaling{}
			}
		} else {
			*(*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr) = DeploymentSpecElasticsearchTopologyAutoscaling{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecElasticsearchTopologyAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecElasticsearchTopologyAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr) = obj
		} else {
			*(*DeploymentSpecElasticsearchTopologyAutoscaling)(ptr) = DeploymentSpecElasticsearchTopologyAutoscaling{}
		}
	default:
		iter.ReportError("decode DeploymentSpecElasticsearchTopologyAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecEnterpriseSearchCodec struct {
}

func (DeploymentSpecEnterpriseSearchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecEnterpriseSearch)(ptr) == nil
}

func (DeploymentSpecEnterpriseSearchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecEnterpriseSearch)(ptr)
	var objs []DeploymentSpecEnterpriseSearch
	if obj != nil {
		objs = []DeploymentSpecEnterpriseSearch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecEnterpriseSearchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecEnterpriseSearch)(ptr) = DeploymentSpecEnterpriseSearch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecEnterpriseSearch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecEnterpriseSearch)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecEnterpriseSearch)(ptr) = DeploymentSpecEnterpriseSearch{}
			}
		} else {
			*(*DeploymentSpecEnterpriseSearch)(ptr) = DeploymentSpecEnterpriseSearch{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecEnterpriseSearch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecEnterpriseSearch)(ptr) = obj
		} else {
			*(*DeploymentSpecEnterpriseSearch)(ptr) = DeploymentSpecEnterpriseSearch{}
		}
	default:
		iter.ReportError("decode DeploymentSpecEnterpriseSearch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecEnterpriseSearchConfigCodec struct {
}

func (DeploymentSpecEnterpriseSearchConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecEnterpriseSearchConfig)(ptr) == nil
}

func (DeploymentSpecEnterpriseSearchConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecEnterpriseSearchConfig)(ptr)
	var objs []DeploymentSpecEnterpriseSearchConfig
	if obj != nil {
		objs = []DeploymentSpecEnterpriseSearchConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearchConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecEnterpriseSearchConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecEnterpriseSearchConfig)(ptr) = DeploymentSpecEnterpriseSearchConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecEnterpriseSearchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecEnterpriseSearchConfig)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecEnterpriseSearchConfig)(ptr) = DeploymentSpecEnterpriseSearchConfig{}
			}
		} else {
			*(*DeploymentSpecEnterpriseSearchConfig)(ptr) = DeploymentSpecEnterpriseSearchConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecEnterpriseSearchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecEnterpriseSearchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecEnterpriseSearchConfig)(ptr) = obj
		} else {
			*(*DeploymentSpecEnterpriseSearchConfig)(ptr) = DeploymentSpecEnterpriseSearchConfig{}
		}
	default:
		iter.ReportError("decode DeploymentSpecEnterpriseSearchConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecIntegrationsServerCodec struct {
}

func (DeploymentSpecIntegrationsServerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecIntegrationsServer)(ptr) == nil
}

func (DeploymentSpecIntegrationsServerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecIntegrationsServer)(ptr)
	var objs []DeploymentSpecIntegrationsServer
	if obj != nil {
		objs = []DeploymentSpecIntegrationsServer{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServer{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecIntegrationsServerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecIntegrationsServer)(ptr) = DeploymentSpecIntegrationsServer{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecIntegrationsServer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecIntegrationsServer)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecIntegrationsServer)(ptr) = DeploymentSpecIntegrationsServer{}
			}
		} else {
			*(*DeploymentSpecIntegrationsServer)(ptr) = DeploymentSpecIntegrationsServer{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecIntegrationsServer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecIntegrationsServer)(ptr) = obj
		} else {
			*(*DeploymentSpecIntegrationsServer)(ptr) = DeploymentSpecIntegrationsServer{}
		}
	default:
		iter.ReportError("decode DeploymentSpecIntegrationsServer", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecIntegrationsServerConfigCodec struct {
}

func (DeploymentSpecIntegrationsServerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecIntegrationsServerConfig)(ptr) == nil
}

func (DeploymentSpecIntegrationsServerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecIntegrationsServerConfig)(ptr)
	var objs []DeploymentSpecIntegrationsServerConfig
	if obj != nil {
		objs = []DeploymentSpecIntegrationsServerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecIntegrationsServerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecIntegrationsServerConfig)(ptr) = DeploymentSpecIntegrationsServerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecIntegrationsServerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecIntegrationsServerConfig)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecIntegrationsServerConfig)(ptr) = DeploymentSpecIntegrationsServerConfig{}
			}
		} else {
			*(*DeploymentSpecIntegrationsServerConfig)(ptr) = DeploymentSpecIntegrationsServerConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecIntegrationsServerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecIntegrationsServerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecIntegrationsServerConfig)(ptr) = obj
		} else {
			*(*DeploymentSpecIntegrationsServerConfig)(ptr) = DeploymentSpecIntegrationsServerConfig{}
		}
	default:
		iter.ReportError("decode DeploymentSpecIntegrationsServerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecKibanaCodec struct {
}

func (DeploymentSpecKibanaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecKibana)(ptr) == nil
}

func (DeploymentSpecKibanaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecKibana)(ptr)
	var objs []DeploymentSpecKibana
	if obj != nil {
		objs = []DeploymentSpecKibana{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibana{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecKibanaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecKibana)(ptr) = DeploymentSpecKibana{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecKibana

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibana{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecKibana)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecKibana)(ptr) = DeploymentSpecKibana{}
			}
		} else {
			*(*DeploymentSpecKibana)(ptr) = DeploymentSpecKibana{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecKibana

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibana{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecKibana)(ptr) = obj
		} else {
			*(*DeploymentSpecKibana)(ptr) = DeploymentSpecKibana{}
		}
	default:
		iter.ReportError("decode DeploymentSpecKibana", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecKibanaConfigCodec struct {
}

func (DeploymentSpecKibanaConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecKibanaConfig)(ptr) == nil
}

func (DeploymentSpecKibanaConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecKibanaConfig)(ptr)
	var objs []DeploymentSpecKibanaConfig
	if obj != nil {
		objs = []DeploymentSpecKibanaConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibanaConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecKibanaConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecKibanaConfig)(ptr) = DeploymentSpecKibanaConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecKibanaConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibanaConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecKibanaConfig)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecKibanaConfig)(ptr) = DeploymentSpecKibanaConfig{}
			}
		} else {
			*(*DeploymentSpecKibanaConfig)(ptr) = DeploymentSpecKibanaConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecKibanaConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecKibanaConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecKibanaConfig)(ptr) = obj
		} else {
			*(*DeploymentSpecKibanaConfig)(ptr) = DeploymentSpecKibanaConfig{}
		}
	default:
		iter.ReportError("decode DeploymentSpecKibanaConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentSpecObservabilityCodec struct {
}

func (DeploymentSpecObservabilityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentSpecObservability)(ptr) == nil
}

func (DeploymentSpecObservabilityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentSpecObservability)(ptr)
	var objs []DeploymentSpecObservability
	if obj != nil {
		objs = []DeploymentSpecObservability{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecObservability{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentSpecObservabilityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentSpecObservability)(ptr) = DeploymentSpecObservability{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentSpecObservability

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecObservability{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentSpecObservability)(ptr) = objs[0]
			} else {
				*(*DeploymentSpecObservability)(ptr) = DeploymentSpecObservability{}
			}
		} else {
			*(*DeploymentSpecObservability)(ptr) = DeploymentSpecObservability{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj DeploymentSpecObservability

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentSpecObservability{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*DeploymentSpecObservability)(ptr) = obj
		} else {
			*(*DeploymentSpecObservability)(ptr) = DeploymentSpecObservability{}
		}
	default:
		iter.ReportError("decode DeploymentSpecObservability", "unexpected JSON type")
	}
}
